---
comments: true
---


## 특징

- 가독성: Coroutine은 동기 코드와 유사한 구문을 사용하여 비동기 작업을 표현할 수 있습니다. 이는 코드의 가독성을 향상시키고, 비동기 작업의 흐름을 이해하기 쉽게 만듭니다. 콜백 함수를 사용하는 기존의 비동기 처리 방식에 비해 코드의 복잡성을 줄일 수 있습니다.
- 순차적인 코드 작성: Coroutine을 사용하면 순차적인 코드로 비동기 작업을 작성할 수 있습니다. 즉, 비동기 작업을 여러 단계로 나누고 각 단계를 순차적으로 실행할 수 있습니다. 이는 코드의 로직을 이해하기 쉽게 만들어주며, 에러 처리와 제어 흐름을 단순화할 수 있습니다.
- 상태 유지: Coroutine은 상태를 유지할 수 있습니다. 이는 비동기 작업이 여러 단계에 걸쳐 이루어져야 하는 경우 매우 유용합니다. Coroutine은 각 단계에서 상태를 저장하고 다음 단계에서 이어서 실행할 수 있습니다. 이를 통해 비동기 작업의 일시 중지와 재개가 가능하며, 작업을 유지하면서도 코드를 단순화할 수 있습니다.
- 에러 처리: Coroutine은 예외 처리를 간편하게 만듭니다. 일반적인 동기 코드와 마찬가지로 try-catch 구문을 사용하여 예외를 처리할 수 있습니다. 또한 Coroutine은 예외 처리를 작업의 단계별로 구성할 수 있어 디버깅과 오류 처리를 용이하게 합니다.
- 확장성: Coroutine은 일반적인 비동기 작업 이외에도 다양한 동시성 작업에 유용합니다. 여러 개의 비동기 작업을 병렬로 실행하거나, 동기화를 필요로 하는 작업을 순차적으로 실행하는 등 다양한 동시성 패턴을 지원합니다.

## CoroutineScope

모든 코루틴은 Scope 내에서 실행이 되어야 한다.

GlobalScope는 앱의 생명주기와 함께 동작하기 때문에 별도 생명 주기 관리가 필요 없으며 앱에서 사이클 긴 케이스에 적합하다.

CoroutineScope는 버튼을 눌러 다운로드하거나 서버와 통신한다거나 하는 등의 필요할 때만 시작, 완료되면 종료하는 용도로 권장된다.

번외로 ViewModelScope 라는 것도 존재하는데, 이는 Jetpack 아키텍처의 뷰모델 컴포넌트를 사용할 때 ViewModel 에서 사용하기 위해 제공되는 Scope이다. 해당 스코프로 실행되는 코루틴은 ViewModel 이 destory될 때 자동으로 취소가 된다.

## Dispatchers의 종류와 특징

CoroutineScope의 경우 GlobalScope와는 다르게 Dispatcher 라는 것을 지정할 수 있는데 이는 코루틴이 실행될 스레드를 지정하는 것이라고 생각하면 된다.

이러한 Dispatcher에는 Default, IO, Main, Unconfined 등이 있고 다른 특징들이 있다.

- Dispatchers.Main: 안드로이드의 주 메인(UI) 스레드에서 동작합니다. UI 업데이트와 사용자 상호작용을 처리하기에 적합합니다.
- Dispatchers.IO: 네트워크 요청, 파일 I/O 및 기타 입출력 작업을 처리하기에 적합한 스레드 풀입니다. 백그라운드에서 CPU를 많이 사용하지 않는 작업에 적합합니다.
- Dispatchers.Default: CPU 집약적인 작업을 처리하기에 적합한 스레드 풀입니다. IO와 UI 작업을 포함한 일반적인 작업에 사용됩니다.
- Dispatchers.Unconfined: 현재 실행중인 스레드를 그대로 사용합니다. 특정 스레드에 구속되지 않으므로 사용 시 주의가 필요합니다.
